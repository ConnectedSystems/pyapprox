

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Multi-index Stochastic Collocation &mdash; PyApprox 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/gallery-dataframe.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"V": ["{\\boldsymbol{#1}}", 1], "mean": ["{\\mathbb{E}\\left[#1\\right]}", 1], "var": ["{\\mathbb{V}\\left[#1\\right]}", 1], "argmin": "{\\mathrm{argmin}}", "rv": "z", "reals": "\\mathbb{R}", "pdf": "\\rho", "rvdom": "\\Gamma", "coloneqq": "\\colon=", "norm": ["{\\lVert #1 \\rVert}", 1], "argmax": ["\\operatorname{argmax}"], "covar": ["\\mathbb{C}\\text{ov}\\left[#1,#2\\right]", 2], "corr": ["\\mathbb{C}\\text{or}\\left[#1,#2\\right]", 2], "ai": "\\alpha", "bi": "\\beta", "dx": ["\\;\\mathrm{d}#1", 1]}}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> PyApprox
          

          
            
            <img src="../../_static/pyapprox-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../auto_tutorials/index.html">PyApprox Tutorials</a></li>
</ul>
<p class="caption"><span class="caption-text">Benchmarks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../benchmarks.html">Benchmarks</a></li>
</ul>
<p class="caption"><span class="caption-text">User Reference Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../user_reference_guide.html">User Reference Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Reference Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Developer Reference Guide</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyApprox</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Multi-index Stochastic Collocation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/auto_examples/multi_fidelity/plot_multi_index_collocation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-auto-examples-multi-fidelity-plot-multi-index-collocation-py"><span class="std std-ref">here</span></a>     to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="multi-index-stochastic-collocation">
<span id="sphx-glr-auto-examples-multi-fidelity-plot-multi-index-collocation-py"></span><h1>Multi-index Stochastic Collocation<a class="headerlink" href="#multi-index-stochastic-collocation" title="Permalink to this headline">Â¶</a></h1>
<p>This tutorial describes how to implement and deploy multi-index collocation to construct a surrogate of the output of a high-fidelity model using a set of lower-fidelity models of lower accuracy and cost.</p>
<p>Despite the improved efficiency of surrogate methods relative to MC sampling, building a surrogate can still be prohibitively expensive for high-fidelity simulation models. Fortunately, a selection of models of varying fidelity and computational cost are typically available for many applications. For example, aerospace models span fluid dynamics, structural and thermal response, control systems, etc.</p>
<p>Leveraging an ensemble of models can facilitate significant reductions in the overall computational cost of UQ, by integrating the predictions of quantities of interest (QoI) from multiple sources.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{\partial u}{\partial t}(x,t,\rv) + \nabla u(x,t,\rv)-\nabla\cdot\left[k(x,\rv) \nabla u(x,t,\rv)\right] &amp;= g(x,t) \qquad\qquad (x,t,\rv)\in D\times [0,1]\times\rvdom\\
u(x,t,\rv)&amp;=0 \qquad\qquad\qquad (x,t,\rv)\in \partial D\times[0,1]\times\rvdom\end{split}\]</div>
<p>with forcing <span class="math notranslate nohighlight">\(g(x,t)=(1.5+\cos(2\pi t))\cos(x_1)\)</span>, and subject to the initial condition <span class="math notranslate nohighlight">\(u(x,0,\rv)=0\)</span>. Following <a class="reference internal" href="../../auto_tutorials/foundations/plot_advection_diffusion_model.html#ntwsiamna2008" id="id1"><span>[NTWSIAMNA2008]</span></a>, we model the diffusivity <span class="math notranslate nohighlight">\(k\)</span> as a random field represented by the
Karhunen-Loeve (like) expansion (KLE)</p>
<div class="math notranslate nohighlight">
\[\log(k(x,\rv)-0.5)=1+\rv_1\left(\frac{\sqrt{\pi L}}{2}\right)^{1/2}+\sum_{k=2}^d \lambda_k\phi(x)\rv_k,\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[\begin{split}\lambda_k=\left(\sqrt{\pi L}\right)^{1/2}\exp\left(-\frac{(\lfloor\frac{k}{2}\rfloor\pi L)^2}{4}\right) k&gt;1,  \qquad\qquad  \phi(x)=
  \begin{cases}
    \sin\left(\frac{(\lfloor\frac{k}{2}\rfloor\pi x_1)}{L_p}\right) &amp; k \text{ even}\,,\\
    \cos\left(\frac{(\lfloor\frac{k}{2}\rfloor\pi x_1)}{L_p}\right) &amp; k \text{ odd}\,.
  \end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(L_p=\max(1,2L_c)\)</span>, <span class="math notranslate nohighlight">\(L=\frac{L_c}{L_p}\)</span> and <span class="math notranslate nohighlight">\(L_c=0.5\)</span>.</p>
<p>We choose a random field which is effectively one-dimensional so that the error in the finite element solution is more sensitive to refinement of the mesh in the <span class="math notranslate nohighlight">\(x_1\)</span>-direction than to refinement in the <span class="math notranslate nohighlight">\(x_2\)</span>-direction.</p>
<p>The advection diffusion equation is solved using linear finite elements and implicit backward-Euler timestepping implemented using <a class="reference external" href="https://fenicsproject.org/">Fenics</a>. In the following we will show how solving the PDE with varying numbers of finite elements and timesteps can reduce the cost of approximating the quantity of interest</p>
<div class="math notranslate nohighlight">
\[f(\rv)=\int_D u(\rv)\frac{1}{2\pi\sigma^2}\exp\left(-\frac{\lVert x-x^\star \rVert_2^2}{\sigma^2}\right)\,dx,\]</div>
<p>where <span class="math notranslate nohighlight">\(x^\star=(0.3,0.5)\)</span> and <span class="math notranslate nohighlight">\(\sigma=0.16\)</span>.</p>
<p>Lets first consider a simple example with one unknown parameter. The following sets up the problem</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pyapprox</span> <span class="k">as</span> <span class="nn">pya</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">uniform</span>
<span class="kn">from</span> <span class="nn">pyapprox.models.wrappers</span> <span class="kn">import</span> <span class="n">MultiLevelWrapper</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">nmodels</span>  <span class="o">=</span> <span class="mi">3</span>
<span class="n">nrandom_vars</span><span class="p">,</span> <span class="n">corr_len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="n">max_eval_concurrency</span> <span class="o">=</span> <span class="mi">1</span>
<span class="kn">from</span> <span class="nn">pyapprox.benchmarks.benchmarks</span> <span class="kn">import</span> <span class="n">setup_benchmark</span>
<span class="n">benchmark</span> <span class="o">=</span> <span class="n">setup_benchmark</span><span class="p">(</span>
    <span class="s1">&#39;multi_level_advection_diffusion&#39;</span><span class="p">,</span><span class="n">nvars</span><span class="o">=</span><span class="n">nrandom_vars</span><span class="p">,</span><span class="n">corr_len</span><span class="o">=</span><span class="n">corr_len</span><span class="p">,</span>
    <span class="n">max_eval_concurrency</span><span class="o">=</span><span class="n">max_eval_concurrency</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">benchmark</span><span class="o">.</span><span class="n">fun</span>
<span class="n">variable</span> <span class="o">=</span> <span class="n">benchmark</span><span class="o">.</span><span class="n">variable</span>
</pre></div>
</div>
<p>Now lets us plot each model as a function of the random variable</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lb</span><span class="p">,</span><span class="n">ub</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">get_statistics</span><span class="p">(</span><span class="s1">&#39;interval&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">nsamples</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">random_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span><span class="n">ub</span><span class="p">,</span><span class="n">nsamples</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
<span class="n">config_vars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nmodels</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
<span class="n">samples</span> <span class="o">=</span> <span class="n">pya</span><span class="o">.</span><span class="n">get_all_sample_combinations</span><span class="p">(</span><span class="n">random_samples</span><span class="p">,</span><span class="n">config_vars</span><span class="p">)</span>
<span class="n">values</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">values</span><span class="p">,(</span><span class="n">nsamples</span><span class="p">,</span><span class="n">nmodels</span><span class="p">))</span>

<span class="kn">import</span> <span class="nn">dolfin</span> <span class="k">as</span> <span class="nn">dl</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">nmodels</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="mi">6</span><span class="p">))</span>
<span class="n">config_samples</span> <span class="o">=</span> <span class="n">benchmark</span><span class="p">[</span><span class="s1">&#39;multi_level_model&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map_to_multidimensional_index</span><span class="p">(</span><span class="n">config_vars</span><span class="p">)</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmodels</span><span class="p">):</span>
    <span class="n">nx</span><span class="p">,</span><span class="n">ny</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">get_mesh_resolution</span><span class="p">(</span><span class="n">config_samples</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="n">ii</span><span class="p">])</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">get_timestep</span><span class="p">(</span><span class="n">config_samples</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">ii</span><span class="p">])</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">dl</span><span class="o">.</span><span class="n">RectangleMesh</span><span class="p">(</span><span class="n">dl</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span><span class="n">dl</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">nmodels</span><span class="p">,</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$f_</span><span class="si">%d</span><span class="s1">$&#39;</span><span class="o">%</span><span class="n">ii</span>
    <span class="k">if</span> <span class="n">ii</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">nmodels</span><span class="p">,</span><span class="n">nmodels</span><span class="o">+</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">nmodels</span><span class="p">,</span><span class="n">nmodels</span><span class="o">+</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">random_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="n">values</span><span class="p">[:,</span><span class="n">ii</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ii</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$f_</span><span class="si">%d</span><span class="s1">-f_</span><span class="si">%d</span><span class="s1">$&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">random_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="n">values</span><span class="p">[:,</span><span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="n">values</span><span class="p">[:,</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="c1">#plt.show()</span>
</pre></div>
</div>
<img alt="plot multi index collocation" class="sphx-glr-single-img" src="../../_images/sphx_glr_plot_multi_index_collocation_001.png" />
<p>The first row shows the spatial mesh of each model and the second row depicts the model response and the discrepancy between two consecutive models. The difference between the model output decreases as the resolution of the mesh is increased. Thus as the cost of the model increases (with increasing resolution) we need less samples to resolve</p>
<p>Lets now construct a multi-level approximation with the same model but more random variables. We will need a model that takes in only 1 configuration variable. We can do this with the <code class="xref py py-class docutils literal notranslate"><span class="pre">MultiLevelWrapper</span></code>. Here we will call another benchmark which is the same advection diffusion problem but with the multi-level wrapper already in place. Here the levels have the one-to-one mapping [0,1,2,â¦]-&gt;[[0,0,0],[1,1,1],[2,2,2],â¦]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nrandom_vars</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">benchmark</span> <span class="o">=</span> <span class="n">setup_benchmark</span><span class="p">(</span>
    <span class="s1">&#39;multi_level_advection_diffusion&#39;</span><span class="p">,</span><span class="n">nvars</span><span class="o">=</span><span class="n">nrandom_vars</span><span class="p">,</span><span class="n">corr_len</span><span class="o">=</span><span class="n">corr_len</span><span class="p">,</span>
    <span class="n">max_eval_concurrency</span><span class="o">=</span><span class="n">max_eval_concurrency</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">benchmark</span><span class="o">.</span><span class="n">fun</span>
<span class="n">variable</span> <span class="o">=</span> <span class="n">benchmark</span><span class="o">.</span><span class="n">variable</span>
</pre></div>
</div>
<p>First define the levels of the multi-level model we will use. Will will skip level 0 and use levels 1,2, and 3. Thus we must define a transformation that converts the sparse grid indices starting at 0 to these levels. We can do this with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyapprox.adaptive_sparse_grid</span> <span class="kn">import</span> <span class="n">ConfigureVariableTransformation</span>
<span class="n">level_indices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="n">config_var_trans</span> <span class="o">=</span> <span class="n">ConfigureVariableTransformation</span><span class="p">(</span><span class="n">level_indices</span><span class="p">)</span>
</pre></div>
</div>
<p>Before building the sparse grid approximation let us define a callback to compute the error and total cost at each step of the sparse grid construction. To do this we will precompute some validation data. Specifically we will evaluate the model using a discretization on level higher than the discretization used to construct the sparse grid. We first generate random samples and then append in the configure variable to each of these samples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">validation_level</span> <span class="o">=</span> <span class="n">level_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
<span class="n">nvalidation_samples</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">random_validation_samples</span> <span class="o">=</span> <span class="n">pya</span><span class="o">.</span><span class="n">generate_independent_random_samples</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span><span class="n">nvalidation_samples</span><span class="p">)</span>
<span class="n">validation_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">random_validation_samples</span><span class="p">,</span><span class="n">validation_level</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">nvalidation_samples</span><span class="p">))])</span>
<span class="n">validation_values</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">validation_samples</span><span class="p">)</span>

<span class="c1">#print(model.work_tracker.costs)</span>

<span class="n">errors</span><span class="p">,</span><span class="n">total_cost</span> <span class="o">=</span> <span class="p">[],[]</span>
<span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">approx</span><span class="p">):</span>
    <span class="n">approx_values</span><span class="o">=</span><span class="n">approx</span><span class="o">.</span><span class="n">evaluate_using_all_data</span><span class="p">(</span>
        <span class="n">validation_samples</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
        <span class="n">validation_values</span><span class="o">-</span><span class="n">approx_values</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">validation_samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
    <span class="n">total_cost</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">approx</span><span class="o">.</span><span class="n">num_equivalent_function_evaluations</span><span class="p">)</span>
</pre></div>
</div>
<p>We can add this callback to the sparse grid options. We define <code class="docutils literal notranslate"><span class="pre">max_nsamples</span></code>
to be the total cost used to evaluate all samples in the sparse grid</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">max_nsamples</span> <span class="o">=</span> <span class="mi">100</span>
<span class="kn">from</span> <span class="nn">pyapprox.multifidelity</span> <span class="kn">import</span> <span class="n">adaptive_approximate_multi_index_sparse_grid</span>
<span class="n">cost_function</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cost_function</span>
<span class="k">def</span> <span class="nf">cost_function</span><span class="p">(</span><span class="n">multilevel_config_sample</span><span class="p">):</span>
    <span class="n">config_sample</span> <span class="o">=</span> <span class="n">benchmark</span><span class="o">.</span><span class="n">multi_level_model</span><span class="o">.</span><span class="n">map_to_multidimensional_index</span><span class="p">(</span>
        <span class="n">multilevel_config_sample</span><span class="p">)</span>
    <span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">get_mesh_resolution</span><span class="p">(</span><span class="n">config_sample</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">get_timestep</span><span class="p">(</span><span class="n">config_sample</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">ndofs</span> <span class="o">=</span> <span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">final_time</span><span class="o">/</span><span class="n">dt</span>
    <span class="k">return</span> <span class="n">ndofs</span><span class="o">/</span><span class="mf">1e5</span>

<span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;config_var_trans&#39;</span><span class="p">:</span><span class="n">config_var_trans</span><span class="p">,</span><span class="s1">&#39;max_nsamples&#39;</span><span class="p">:</span><span class="n">max_nsamples</span><span class="p">,</span>
           <span class="s1">&#39;config_variables_idx&#39;</span><span class="p">:</span><span class="n">nrandom_vars</span><span class="p">,</span><span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
           <span class="s1">&#39;cost_function&#39;</span><span class="p">:</span><span class="n">cost_function</span><span class="p">,</span>
           <span class="s1">&#39;max_level_1d&#39;</span><span class="p">:[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span><span class="o">*</span><span class="n">nrandom_vars</span><span class="o">+</span><span class="p">[</span>
               <span class="nb">len</span><span class="p">(</span><span class="n">level_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">level_indices</span><span class="p">),</span>
           <span class="s1">&#39;callback&#39;</span><span class="p">:</span><span class="n">callback</span><span class="p">}</span>
</pre></div>
</div>
<p>Now lets us build the sparse grid</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sparse_grid</span> <span class="o">=</span> <span class="n">adaptive_approximate_multi_index_sparse_grid</span><span class="p">(</span>
    <span class="n">model</span><span class="p">,</span><span class="n">variable</span><span class="o">.</span><span class="n">all_variables</span><span class="p">(),</span><span class="n">options</span><span class="p">)</span>

<span class="c1"># #%%</span>
<span class="c1"># #Lets plot the errors</span>
<span class="c1"># fig, ax = plt.subplots(1,1,figsize=(8,6))</span>
<span class="c1"># plt.loglog(total_cost,errors)</span>
<span class="c1"># plt.show()</span>
</pre></div>
</div>
<p>Now lets build a single fidelity approximation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">multi_level_indices</span> <span class="o">=</span> <span class="n">level_indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">level_indices</span> <span class="o">=</span> <span class="p">[[</span><span class="n">level_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span>
<span class="n">config_var_trans</span> <span class="o">=</span> <span class="n">ConfigureVariableTransformation</span><span class="p">(</span><span class="n">level_indices</span><span class="p">)</span>
<span class="c1">#cost_function = model.cost_function</span>
<span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;config_var_trans&#39;</span><span class="p">:</span><span class="n">config_var_trans</span><span class="p">,</span><span class="s1">&#39;max_nsamples&#39;</span><span class="p">:</span><span class="n">max_nsamples</span><span class="p">,</span>
           <span class="s1">&#39;config_variables_idx&#39;</span><span class="p">:</span><span class="n">nrandom_vars</span><span class="p">,</span><span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
           <span class="s1">&#39;cost_function&#39;</span><span class="p">:</span><span class="n">cost_function</span><span class="p">,</span>
           <span class="s1">&#39;max_level_1d&#39;</span><span class="p">:[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span><span class="o">*</span><span class="n">nrandom_vars</span><span class="o">+</span><span class="p">[</span>
               <span class="nb">len</span><span class="p">(</span><span class="n">level_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">level_indices</span><span class="p">),</span>
           <span class="s1">&#39;callback&#39;</span><span class="p">:</span><span class="n">callback</span><span class="p">}</span>
</pre></div>
</div>
<p>Now lets us build the sparse grid. First reset the callback counters and save the previous errors</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">multi_level_errors</span><span class="p">,</span><span class="n">multi_level_total_cost</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">total_cost</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">errors</span><span class="p">,</span><span class="n">total_cost</span> <span class="o">=</span> <span class="p">[],[]</span>
<span class="n">sparse_grid</span> <span class="o">=</span> <span class="n">adaptive_approximate_multi_index_sparse_grid</span><span class="p">(</span>
    <span class="n">model</span><span class="p">,</span><span class="n">variable</span><span class="o">.</span><span class="n">all_variables</span><span class="p">(),</span><span class="n">options</span><span class="p">)</span>
</pre></div>
</div>
<p>Lets plot the errors</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">multi_level_total_cost</span><span class="p">,</span><span class="n">multi_level_errors</span><span class="p">,</span>
           <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\mathrm</span><span class="si">{Multi}</span><span class="s1">-\mathrm</span><span class="si">{level}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">total_cost</span><span class="p">,</span><span class="n">errors</span><span class="p">,</span>
           <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\mathrm</span><span class="si">{Single}</span><span class="s1">-\mathrm</span><span class="si">{Fidelity}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<img alt="plot multi index collocation" class="sphx-glr-single-img" src="../../_images/sphx_glr_plot_multi_index_collocation_002.png" />
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend object at 0x1c313fe350&gt;
</pre></div>
</div>
<p>Now lets build a multi-index approximation of the same model but now with more random variables. We again create the same benchmark but this time one that allows us to vary the two spatial mesh resolutions and the timestep independently</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">benchmark</span> <span class="o">=</span> <span class="n">setup_benchmark</span><span class="p">(</span>
    <span class="s1">&#39;multi_index_advection_diffusion&#39;</span><span class="p">,</span><span class="n">nvars</span><span class="o">=</span><span class="n">nrandom_vars</span><span class="p">,</span><span class="n">corr_len</span><span class="o">=</span><span class="n">corr_len</span><span class="p">,</span>
    <span class="n">max_eval_concurrency</span><span class="o">=</span><span class="n">max_eval_concurrency</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">benchmark</span><span class="o">.</span><span class="n">fun</span>
<span class="n">variable</span> <span class="o">=</span> <span class="n">benchmark</span><span class="o">.</span><span class="n">variable</span>
</pre></div>
</div>
<p>Again we define the ConfigureVariableTransformation and define the appropriate options. Notice the different in max_level_1d. (print it; it should be longer than the single fidelity and multi-level versions)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyapprox.adaptive_sparse_grid</span> <span class="kn">import</span> <span class="n">ConfigureVariableTransformation</span>
<span class="n">level_indices</span> <span class="o">=</span> <span class="n">multi_level_indices</span><span class="o">*</span><span class="mi">3</span>
<span class="n">config_var_trans</span> <span class="o">=</span> <span class="n">ConfigureVariableTransformation</span><span class="p">(</span><span class="n">level_indices</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">pyapprox.multifidelity</span> <span class="kn">import</span> <span class="n">adaptive_approximate_multi_index_sparse_grid</span>
<span class="c1">#cost_function = model.cost_function</span>
<span class="k">def</span> <span class="nf">cost_function</span><span class="p">(</span><span class="n">config_sample</span><span class="p">):</span>
    <span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">get_mesh_resolution</span><span class="p">(</span><span class="n">config_sample</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">get_timestep</span><span class="p">(</span><span class="n">config_sample</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">ndofs</span> <span class="o">=</span> <span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">base_model</span><span class="o">.</span><span class="n">final_time</span><span class="o">/</span><span class="n">dt</span>
    <span class="k">return</span> <span class="n">ndofs</span><span class="o">/</span><span class="mf">1e5</span>
<span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;config_var_trans&#39;</span><span class="p">:</span><span class="n">config_var_trans</span><span class="p">,</span><span class="s1">&#39;max_nsamples&#39;</span><span class="p">:</span><span class="n">max_nsamples</span><span class="p">,</span>
           <span class="s1">&#39;config_variables_idx&#39;</span><span class="p">:</span><span class="n">nrandom_vars</span><span class="p">,</span><span class="s1">&#39;verbose&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
           <span class="s1">&#39;cost_function&#39;</span><span class="p">:</span><span class="n">cost_function</span><span class="p">,</span>
           <span class="s1">&#39;max_level_1d&#39;</span><span class="p">:[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span><span class="o">*</span><span class="n">nrandom_vars</span><span class="o">+</span><span class="p">[</span>
               <span class="nb">len</span><span class="p">(</span><span class="n">level_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">level_indices</span><span class="p">),</span>
           <span class="s1">&#39;callback&#39;</span><span class="p">:</span><span class="n">callback</span><span class="p">}</span>

<span class="n">single_fidelity_errors</span><span class="p">,</span><span class="n">single_fidelity_total_cost</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">total_cost</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">errors</span><span class="p">,</span><span class="n">total_cost</span> <span class="o">=</span> <span class="p">[],[]</span>
<span class="n">sparse_grid</span> <span class="o">=</span> <span class="n">adaptive_approximate_multi_index_sparse_grid</span><span class="p">(</span>
    <span class="n">model</span><span class="p">,</span><span class="n">variable</span><span class="o">.</span><span class="n">all_variables</span><span class="p">(),</span><span class="n">options</span><span class="p">)</span>
</pre></div>
</div>
<p>Lets plot the errors</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">multi_level_total_cost</span><span class="p">,</span><span class="n">multi_level_errors</span><span class="p">,</span>
           <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\mathrm</span><span class="si">{Multi}</span><span class="s1">-\mathrm</span><span class="si">{level}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">single_fidelity_total_cost</span><span class="p">,</span><span class="n">single_fidelity_errors</span><span class="p">,</span>
           <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\mathrm</span><span class="si">{Single}</span><span class="s1">-\mathrm</span><span class="si">{Fidelity}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">total_cost</span><span class="p">,</span><span class="n">errors</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\mathrm</span><span class="si">{Multi}</span><span class="s1">-\mathrm</span><span class="si">{index}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img alt="plot multi index collocation" class="sphx-glr-single-img" src="../../_images/sphx_glr_plot_multi_index_collocation_003.png" />
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">Â¶</a></h2>
<dl class="citation">
<dt class="label" id="tjwgsiamuq2015"><span class="brackets">TJWGSIAMUQ2015</span></dt>
<dd><p><a class="reference external" href="https://doi.org/10.1137/140969002">Teckentrup, A. and Jantsch, P. and Webster, C. and Gunzburger, M. A Multilevel Stochastic Collocation Method for Partial Differential Equations with Random Input Data. SIAM/ASA Journal on Uncertainty Quantification, 3(1), 1046-1074, 2015.</a></p>
</dd>
<dt class="label" id="hnttcmame2016"><span class="brackets">HNTTCMAME2016</span></dt>
<dd><p><a class="reference external" href="https://doi.org/10.1016/j.cma.2016.03.029">Haji-Ali, A. and Nobile, F. and Tamellini, L. and Tempone, R. Multi-Index Stochastic Collocation for random PDEs. Computer Methods in Applied Mechanics and Engineering, 306, 95-122, 2016.</a></p>
</dd>
<dt class="label" id="jeggijnme2020"><span class="brackets">JEGGIJNME2020</span></dt>
<dd><p><a class="reference external" href="https://doi.org/10.1002/nme.6268">Jakeman, J.D., Eldred, M.S., Geraci, G., Gorodetsky, A. Adaptive multi-index collocation for uncertainty quantification and sensitivity analysis. Int J Numer Methods Eng. 2020; 121: 1314â 1343.</a></p>
</dd>
</dl>
<p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 12 minutes  24.149 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-auto-examples-multi-fidelity-plot-multi-index-collocation-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../../_downloads/85eb0506e4309f481e9913796ab0b942/plot_multi_index_collocation.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">plot_multi_index_collocation.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../../_downloads/041998588b7e7e6ff7ff79f2ab692608/plot_multi_index_collocation.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">plot_multi_index_collocation.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019 National Technology &amp; Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>